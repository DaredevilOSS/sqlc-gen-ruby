# auto-generated by sqlc - do not edit
require 'connection_pool'
require 'pg'
require 'set'

module PgCodegen
		GetAuthorSql = %q(SELECT id, name, bio FROM authors
		WHERE id = $1 LIMIT 1)
		
		GetAuthorRow = Struct.new(		:id, :name, :bio)
		
		GetAuthorArgs = Struct.new(		:id)
		
		ListAuthorsSql = %q(SELECT id, name, bio FROM authors
		ORDER BY name)
		
		ListAuthorsRow = Struct.new(		:id, :name, :bio)
		
		CreateAuthorSql = %q(INSERT INTO authors (
		    name, bio
		) VALUES (
		    $1, $2
		)
		RETURNING id, name, bio)
		
		CreateAuthorRow = Struct.new(		:id, :name, :bio)
		
		CreateAuthorArgs = Struct.new(		:name, :bio)
		
		DeleteAuthorSql = %q(DELETE FROM authors
		WHERE id = $1)
		
		DeleteAuthorArgs = Struct.new(		:id)
		
		TestSql = %q(SELECT c_bit, c_smallint, c_boolean, c_integer, c_bigint, c_serial, c_decimal, c_numeric, c_real, c_double_precision, c_date, c_time, c_timestamp, c_char, c_varchar, c_bytea, c_text, c_json FROM node_postgres_types
		LIMIT 1)
		
		TestRow = Struct.new(
				:c_bit,
				:c_smallint,
				:c_boolean,
				:c_integer,
				:c_bigint,
				:c_serial,
				:c_decimal,
				:c_numeric,
				:c_real,
				:c_double_precision,
				:c_date,
				:c_time,
				:c_timestamp,
				:c_char,
				:c_varchar,
				:c_bytea,
				:c_text,
				:c_json
		)
		
		class QuerySql
				def initialize(connection_pool_params, pg_params)
						@pool = ConnectionPool.new(
								**connection_pool_params
						) {
								client = PG.connect(**pg_params)
								client.type_map_for_results = PG::BasicTypeMapForResults.new client
								client
						}
						@prepared_statements = Set[]
				end
				
				def get_author(get_author_args)
						@pool.with do |client|
								query_params = [		get_author_args.id]
								unless @prepared_statements.include?('get_author')
										client.prepare('get_author', GetAuthorSql)
										@prepared_statements.add('get_author')
								end
								result = client.exec_prepared('get_author', query_params)
								row = result.first
								return nil if row.nil?
								entity = GetAuthorRow.new(
										row['id']
										row['name']
										row['bio']
								)
								return entity
						end
				end
				
				def list_authors
						@pool.with do |client|
								unless @prepared_statements.include?('list_authors')
										client.prepare('list_authors', ListAuthorsSql)
										@prepared_statements.add('list_authors')
								end
								result = client.exec_prepared('list_authors')
								entities = []
								result.each do |row|
								entities << ListAuthorsRow.new(
										row['id']
										row['name']
										row['bio']
								)
								end
								return entities
						end
				end
				
				def create_author(create_author_args)
						@pool.with do |client|
								query_params = [		create_author_args.name, create_author_args.bio]
								unless @prepared_statements.include?('create_author')
										client.prepare('create_author', CreateAuthorSql)
										@prepared_statements.add('create_author')
								end
								result = client.exec_prepared('create_author', query_params)
								row = result.first
								return nil if row.nil?
								entity = CreateAuthorRow.new(
										row['id']
										row['name']
										row['bio']
								)
								return entity
						end
				end
				
				def delete_author(delete_author_args)
						@pool.with do |client|
								query_params = [		delete_author_args.id]
								unless @prepared_statements.include?('delete_author')
										client.prepare('delete_author', DeleteAuthorSql)
										@prepared_statements.add('delete_author')
								end
								client.exec_prepared('delete_author', query_params)
						end
				end
				
				def test
						@pool.with do |client|
								unless @prepared_statements.include?('test')
										client.prepare('test', TestSql)
										@prepared_statements.add('test')
								end
								result = client.exec_prepared('test')
								row = result.first
								return nil if row.nil?
								entity = TestRow.new(
										row['c_bit']
										row['c_smallint']
										row['c_boolean']
										row['c_integer']
										row['c_bigint']
										row['c_serial']
										row['c_decimal']
										row['c_numeric']
										row['c_real']
										row['c_double_precision']
										row['c_date']
										row['c_time']
										row['c_timestamp']
										row['c_char']
										row['c_varchar']
										row['c_bytea']
										row['c_text']
										row['c_json']
								)
								return entity
						end
				end
		end
end