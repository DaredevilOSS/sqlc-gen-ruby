# auto-generated by sqlc - do not edit
require 'connection_pool'
require 'pg'
require 'set'

module PgCodegen
	GetAuthorSql = %q(SELECT id, name, bio FROM authors
	WHERE id = $1 LIMIT 1)
	
	class GetAuthorRow < Data.define(:id, :name, :bio)
	end
	
	class GetAuthorArgs < Data.define(:id)
	end
	
	ListAuthorsSql = %q(SELECT id, name, bio FROM authors
	ORDER BY name)
	
	class ListAuthorsRow < Data.define(:id, :name, :bio)
	end
	
	CreateAuthorSql = %q(INSERT INTO authors (
	    name, bio
	) VALUES (
	    $1, $2
	)
	RETURNING id, name, bio)
	
	class CreateAuthorRow < Data.define(:id, :name, :bio)
	end
	
	class CreateAuthorArgs < Data.define(:name, :bio)
	end
	
	DeleteAuthorSql = %q(DELETE FROM authors
	WHERE id = $1)
	
	class DeleteAuthorArgs < Data.define(:id)
	end
	
	TestSql = %q(SELECT c_bit, c_smallint, c_boolean, c_integer, c_bigint, c_serial, c_decimal, c_numeric, c_real, c_double_precision, c_date, c_time, c_timestamp, c_char, c_varchar, c_bytea, c_text, c_json FROM node_postgres_types
	LIMIT 1)
	
	class TestRow < Data.define(
		:c_bit,
		:c_smallint,
		:c_boolean,
		:c_integer,
		:c_bigint,
		:c_serial,
		:c_decimal,
		:c_numeric,
		:c_real,
		:c_double_precision,
		:c_date,
		:c_time,
		:c_timestamp,
		:c_char,
		:c_varchar,
		:c_bytea,
		:c_text,
		:c_json
	)
	end
	
	class QuerySql
		def initialize(connection_pool_params, pg_params)
			@pool = ConnectionPool.new(**connection_pool_params) {
				client = PG.connect(**pg_params)
				client.type_map_for_results = PG::BasicTypeMapForResults.new client
				client
			}
			@prepared_statements = Set[]
		end
		
		def get_author(get_author_args)
			@pool.with do |client|
				query_params = [get_author_args.id]
				unless @prepared_statements.include?('get_author')
					client.prepare('get_author', GetAuthorSql)
					@prepared_statements.add('get_author')
				end
				result = client.exec_prepared('get_author', query_params)
				row = result.first
				return nil if row.nil?
				entity = GetAuthorRow.new(row['id'], row['name'], row['bio'])
				return entity
			end
		end
		
		def list_authors
			@pool.with do |client|
				unless @prepared_statements.include?('list_authors')
					client.prepare('list_authors', ListAuthorsSql)
					@prepared_statements.add('list_authors')
				end
				result = client.exec_prepared('list_authors')
				entities = []
				result.each do |row|
					entities << ListAuthorsRow.new(row['id'], row['name'], row['bio'])
				end
				return entities
			end
		end
		
		def create_author(create_author_args)
			@pool.with do |client|
				query_params = [create_author_args.name, create_author_args.bio]
				unless @prepared_statements.include?('create_author')
					client.prepare('create_author', CreateAuthorSql)
					@prepared_statements.add('create_author')
				end
				result = client.exec_prepared('create_author', query_params)
				row = result.first
				return nil if row.nil?
				entity = CreateAuthorRow.new(row['id'], row['name'], row['bio'])
				return entity
			end
		end
		
		def delete_author(delete_author_args)
			@pool.with do |client|
				query_params = [delete_author_args.id]
				unless @prepared_statements.include?('delete_author')
					client.prepare('delete_author', DeleteAuthorSql)
					@prepared_statements.add('delete_author')
				end
				client.exec_prepared('delete_author', query_params)
			end
		end
		
		def test
			@pool.with do |client|
				unless @prepared_statements.include?('test')
					client.prepare('test', TestSql)
					@prepared_statements.add('test')
				end
				result = client.exec_prepared('test')
				row = result.first
				return nil if row.nil?
				entity = TestRow.new(
					row['c_bit'],
					row['c_smallint'],
					row['c_boolean'],
					row['c_integer'],
					row['c_bigint'],
					row['c_serial'],
					row['c_decimal'],
					row['c_numeric'],
					row['c_real'],
					row['c_double_precision'],
					row['c_date'],
					row['c_time'],
					row['c_timestamp'],
					row['c_char'],
					row['c_varchar'],
					row['c_bytea'],
					row['c_text'],
					row['c_json']
				)
				return entity
			end
		end
	end
end