# auto-generated by sqlc - do not edit
require 'connection_pool'
require 'mysql2'

module Mysql2Codegen
	class QuerySql
		def initialize(connection_pool_params, mysql2_params)
			@pool = ConnectionPool.new(
				**connection_pool_params
			) { new Mysql2::Client(**mysql2_params) }
		end
		
		GetAuthorSql = %q(SELECT id, name, bio FROM authors
		WHERE id = ? LIMIT 1)
		
		GetAuthorRow = Data.define(
			:id,
			:name,
			:bio
		)
		
		GetAuthorArgs = Data.define(
			:id
		)
		
		def get_author(get_author_args)
			@pool.with do |client|
				query_params = [get_author_args.id]
				stmt = client.prepare('get_author', GetAuthorSql)
				result = stmt.execute('get_author', query_params)
				row = result.first
				return nil if row.nil?
				entity = GetAuthorRow.new(
					row['id'],
					row['name'],
					row['bio']
				)
				return entity
			end
		end
		
		ListAuthorsSql = %q(SELECT id, name, bio FROM authors
		ORDER BY name)
		
		ListAuthorsRow = Data.define(
			:id,
			:name,
			:bio
		)
		
		def list_authors
			@pool.with do |client|
				stmt = client.prepare('list_authors', ListAuthorsSql)
				stmt.execute('list_authors')
				entities = []
				result.each do |row|
				entities << ListAuthorsRow.new(
					row['id'],
					row['name'],
					row['bio']
				)
				end
				return entities
			end
		end
		
		CreateAuthorSql = %q(INSERT INTO authors (
		  name, bio
		) VALUES (
		  ?, ? 
		))
		
		CreateAuthorArgs = Data.define(
			:name,
			:bio
		)
		
		def create_author(create_author_args)
			@pool.with do |client|
				query_params = [create_author_args.name, create_author_args.bio]
				stmt = client.prepare('create_author', CreateAuthorSql)
				stmt.execute('create_author', query_params)
			end
		end
		
		UpdateAuthorSql = %q(UPDATE authors 
		SET bio = ?
		WHERE id = ?)
		
		UpdateAuthorArgs = Data.define(
			:bio,
			:id
		)
		
		def update_author(update_author_args)
			@pool.with do |client|
				query_params = [update_author_args.bio, update_author_args.id]
				stmt = client.prepare('update_author', UpdateAuthorSql)
				stmt.execute('update_author', query_params)
			end
		end
		
		CreateAuthorReturnIdSql = %q(INSERT INTO authors (
		    name, bio
		) VALUES (
		    ?, ?
		))
		
		CreateAuthorReturnIdArgs = Data.define(
			:name,
			:bio
		)
		
		def create_author_return_id(create_author_return_id_args)
			@pool.with do |client|
				query_params = [create_author_return_id_args.name, create_author_return_id_args.bio]
				stmt = client.prepare('create_author_return_id', CreateAuthorReturnIdSql)
				stmt.execute('create_author_return_id', query_params)
				return client.last_id
			end
		end
		
		DeleteAuthorSql = %q(DELETE FROM authors
		WHERE id = ?)
		
		DeleteAuthorArgs = Data.define(
			:id
		)
		
		def delete_author(delete_author_args)
			@pool.with do |client|
				query_params = [delete_author_args.id]
				stmt = client.prepare('delete_author', DeleteAuthorSql)
				stmt.execute('delete_author', query_params)
			end
		end
		
		TestSql = %q(SELECT c_bit, c_tinyint, c_bool, c_boolean, c_smallint, c_mediumint, c_int, c_integer, c_bigint, c_serial, c_decimal, c_dec, c_numeric, c_fixed, c_float, c_double, c_double_precision, c_date, c_time, c_datetime, c_timestamp, c_year, c_char, c_nchar, c_national_char, c_varchar, c_binary, c_varbinary, c_tinyblob, c_tinytext, c_blob, c_text, c_mediumblob, c_mediumtext, c_longblob, c_longtext, c_json FROM node_mysql_types
		LIMIT 1)
		
		TestRow = Data.define(
			:c_bit,
			:c_tinyint,
			:c_bool,
			:c_boolean,
			:c_smallint,
			:c_mediumint,
			:c_int,
			:c_integer,
			:c_bigint,
			:c_serial,
			:c_decimal,
			:c_dec,
			:c_numeric,
			:c_fixed,
			:c_float,
			:c_double,
			:c_double_precision,
			:c_date,
			:c_time,
			:c_datetime,
			:c_timestamp,
			:c_year,
			:c_char,
			:c_nchar,
			:c_national_char,
			:c_varchar,
			:c_binary,
			:c_varbinary,
			:c_tinyblob,
			:c_tinytext,
			:c_blob,
			:c_text,
			:c_mediumblob,
			:c_mediumtext,
			:c_longblob,
			:c_longtext,
			:c_json
		)
		
		def test
			@pool.with do |client|
				stmt = client.prepare('test', TestSql)
				result = stmt.execute('test')
				row = result.first
				return nil if row.nil?
				entity = TestRow.new(
					row['c_bit'],
					row['c_tinyint'],
					row['c_bool'],
					row['c_boolean'],
					row['c_smallint'],
					row['c_mediumint'],
					row['c_int'],
					row['c_integer'],
					row['c_bigint'],
					row['c_serial'],
					row['c_decimal'],
					row['c_dec'],
					row['c_numeric'],
					row['c_fixed'],
					row['c_float'],
					row['c_double'],
					row['c_double_precision'],
					row['c_date'],
					row['c_time'],
					row['c_datetime'],
					row['c_timestamp'],
					row['c_year'],
					row['c_char'],
					row['c_nchar'],
					row['c_national_char'],
					row['c_varchar'],
					row['c_binary'],
					row['c_varbinary'],
					row['c_tinyblob'],
					row['c_tinytext'],
					row['c_blob'],
					row['c_text'],
					row['c_mediumblob'],
					row['c_mediumtext'],
					row['c_longblob'],
					row['c_longtext'],
					row['c_json']
				)
				return entity
			end
		end
	end
end